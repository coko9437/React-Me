250814
리액트 메서드

# splice 메서드
: 배열에서 특정 위치에 요소를 추가, 삭제, 또는 교체하는 데 사용
array.splice(   startIndex,    deleteCount,    item1,    item2, ...);
	startIndex: 시작 위치 (0부터 시작)
		deleteCount: 삭제할 요소의 개수
			item1, item2, ...: 추가할 요소들 (생략 가능)
예시[
요소 삭제

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // 2번 인덱스에서 1개의 요소 삭제
console.log(arr); // [1, 2, 4, 5]

요소 추가

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 0, 'a', 'b'); // 2번 인덱스에 요소 추가, 삭제는 없음
console.log(arr); // [1, 2, 'a', 'b', 3, 4, 5]

요소 교체

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 2, 'x', 'y'); // 2번 인덱스부터 2개의 요소 삭제 후 'x', 'y' 추가
console.log(arr); // [1, 2, 'x', 'y', 5]

배열의 끝에서 삭제

let arr = [1, 2, 3, 4, 5];
arr.splice(-1, 1); // 끝에서 1개의 요소 삭제
console.log(arr); // [1, 2, 3, 4]
]

# findIndex 메서드 
:배열에서 조건을 만족하는 첫 번째 요소의 인덱스를 반환.
	 조건을 만족하는 요소가 없으면 -1을 반환
array.findIndex(    callback(   element,    index,    array));
	callback: 배열의 각 요소에 대해 실행할 함수
		element: 배열의 현재 요소
			index (옵션): 배열의 현재 요소의 인덱스
				array (옵션): findIndex를 호출한 배열
- 반환값: 조건을 만족하는 첫 번째 요소의 인덱스, 없으면 -1

예시 [
const numbers = [10, 20, 30, 40];
const index = numbers.findIndex(num => num === 30);
	// index-> {0, 1, 2, 3}
console.log(index); // 2

// 특정 요소 삭제
let arr = [10, 20, 30, 40];
const index = arr.findIndex(num => num === 30);
if (index !== -1) {
 arr.splice(index, 1); // 요소 삭제
}
console.log(arr); // [10, 20, 40]

// 조건 만족 여부 확인
const isFound = arr.findIndex(num => num === 100) !== -1;
console.log(isFound); // false
]

# find 메서드
: 배열에서 조건을 만족하는 첫 번째 요소를 반환 
	없으면 undefined를 반환
array.find(   callback ( element,    index,    array   )   );
	callback: 배열의 각 요소에 대해 실행할 함수
		element: 현재 요소
			index (옵션): 현재 요소의 인덱스
				array (옵션): find를 호출한 배열

반환값: 조건을 만족하는 첫 번째 요소. 만족하는 요소가 없으면 undefined

- 예시[

특정 값 찾기
const numbers = [10, 20, 30, 40];
	const result = numbers.find(num => num === 30);
	console.log(result); // 30

객체 배열에서 특정 요소 찾기

const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];
const user = users.find(user => user.name === 'Bob');
	console.log(user); // { id: 2, name: 'Bob' }
]

# map 메서드
: 배열의 각 요소를 변환하여 새로운 배열을 반환
	원본 배열은 변경되지 않으며, 항상 새로운 배열이 반환
array.map( (  currentValue,   index,   array) => { } );
	     currentValue: 배열의 현재 요소
		index (선택): 배열의 현재 요소의 인덱스
			array (선택): map을 호출한 원본 배열

반환값: 새로운 배열
-예시 [
// 배열의 각 값을 제곱
const numbers = [1, 2, 3, 4];
	const squares = numbers.map((num) => num * num );
	console.log(squares); // [1, 4, 9, 16]

// 객체 배열에서 특정 속성 추출
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' },
	    ];
	const names = users.map((user) => user.name);
	console.log(names); // ['Alice', 'Bob', 'Charlie']
]

# filter 메서드
: 배열의 각 요소를 검사하여 조건 만족하는 요소만 추출, 새로운 배열로 반환
array.filter( (currentValue, index, array) => { } );
// 조건이 true인 경우 요소를 반환
	currentValue: 배열의 현재 요소
		index (선택): 배열의 현재 요소의 인덱스
			array (선택): filter를 호출한 원본 배열

-예시 [

//짝수 필터링
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers =
	 numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]

//객체 배열에서 조건에 맞는 요소 필터링
const users = [
  { id: 1, name: 'Alice', active: true }, //액티브 
  { id: 2, name: 'Bob', active: false },
  { id: 3, name: 'Charlie', active: true },
		];
	const activeUsers =
		 users.filter((user) => user.active); //액티브 활성화
console.log(activeUsers); 
// [{ id: 1, name: 'Alice', active: true }, 
//  { id: 3, name: 'Charlie', active: true }]


]

### 비교 ###
map: 배열의 요소를 변환하여 새로운 배열 생성
모든 요소 포함 (원본 배열과 동일한 크기)
-------
filter: 조건을 만족하는 요소만 새로운 배열에 포함
조건 만족 요소

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

자바스크립트 표현식 사용하기

function App() {
  const name = '리액트';
  return (		          true일때 출력.	false일때 출력.
       {name === '리액트' ? ( 리액트입니다. ) : ( 리액트가 아닙니다. )}     
   ); } 
=> 조건 확인		조건 평가			결과 렌더링
name === '리액트'		? 연산자로 조건 평가		조건에 따라 다른 요소 렌더링


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# props 이해하기

: properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# state 이해하기
: 컴포넌트 내부에서 바뀔 수 있는 값을 의미
[props] 는 부모 컴포넌트가 설정하는 읽기 전용 값이며, 
	[state] 는 컴포넌트 자체적으로 관리하는 값

- 클래스형 컴포넌트
class Counter extends Component {
  	constructor(props) {
    	super(props);
    		// state의 초깃값 설정하기
    		this.state = {
      		number: 0,
    		};
  	}...

여러 값 관리하기		함수형 업데이트		
this.state = {		this.setState(prevState => ({
  number: 0,		number: prevState.number + 1
  fixedNumber: 0,		}));
};

콜백 함수 등록
this.setState(
  { number: number + 1 },
  () => {
    console.log('setState가 완료되었습니다.');
    console.log(this.state);
  }
);