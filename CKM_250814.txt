250814
리액트 메서드

# splice 메서드
: 배열에서 특정 위치에 요소를 추가, 삭제, 또는 교체하는 데 사용
array.splice(   startIndex,    deleteCount,    item1,    item2, ...);
	startIndex: 시작 위치 (0부터 시작)
		deleteCount: 삭제할 요소의 개수
			item1, item2, ...: 추가할 요소들 (생략 가능)
예시[
요소 삭제

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 1); // 2번 인덱스에서 1개의 요소 삭제
console.log(arr); // [1, 2, 4, 5]

요소 추가

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 0, 'a', 'b'); // 2번 인덱스에 요소 추가, 삭제는 없음
console.log(arr); // [1, 2, 'a', 'b', 3, 4, 5]

요소 교체

let arr = [1, 2, 3, 4, 5];
arr.splice(2, 2, 'x', 'y'); // 2번 인덱스부터 2개의 요소 삭제 후 'x', 'y' 추가
console.log(arr); // [1, 2, 'x', 'y', 5]

배열의 끝에서 삭제

let arr = [1, 2, 3, 4, 5];
arr.splice(-1, 1); // 끝에서 1개의 요소 삭제
console.log(arr); // [1, 2, 3, 4]
]

# findIndex 메서드 
:배열에서 조건을 만족하는 첫 번째 요소의 인덱스를 반환.
	 조건을 만족하는 요소가 없으면 -1을 반환
array.findIndex(    callback(   element,    index,    array));
	callback: 배열의 각 요소에 대해 실행할 함수
		element: 배열의 현재 요소
			index (옵션): 배열의 현재 요소의 인덱스
				array (옵션): findIndex를 호출한 배열
- 반환값: 조건을 만족하는 첫 번째 요소의 인덱스, 없으면 -1

예시 [
const numbers = [10, 20, 30, 40];
const index = numbers.findIndex(num => num === 30);
	// index-> {0, 1, 2, 3}
console.log(index); // 2

// 특정 요소 삭제
let arr = [10, 20, 30, 40];
const index = arr.findIndex(num => num === 30);
if (index !== -1) {
 arr.splice(index, 1); // 요소 삭제
}
console.log(arr); // [10, 20, 40]

// 조건 만족 여부 확인
const isFound = arr.findIndex(num => num === 100) !== -1;
console.log(isFound); // false
]

# find 메서드
: 배열에서 조건을 만족하는 첫 번째 요소를 반환 
	없으면 undefined를 반환
array.find(   callback ( element,    index,    array   )   );
	callback: 배열의 각 요소에 대해 실행할 함수
		element: 현재 요소
			index (옵션): 현재 요소의 인덱스
				array (옵션): find를 호출한 배열

반환값: 조건을 만족하는 첫 번째 요소. 만족하는 요소가 없으면 undefined

- 예시[

특정 값 찾기
const numbers = [10, 20, 30, 40];
	const result = numbers.find(num => num === 30);
	console.log(result); // 30

객체 배열에서 특정 요소 찾기

const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];
const user = users.find(user => user.name === 'Bob');
	console.log(user); // { id: 2, name: 'Bob' }
]

# map 메서드
: 배열의 각 요소를 변환하여 새로운 배열을 반환
	원본 배열은 변경되지 않으며, 항상 새로운 배열이 반환
array.map( (  currentValue,   index,   array) => { } );
	     currentValue: 배열의 현재 요소
		index (선택): 배열의 현재 요소의 인덱스
			array (선택): map을 호출한 원본 배열

반환값: 새로운 배열
-예시 [
// 배열의 각 값을 제곱
const numbers = [1, 2, 3, 4];
	const squares = numbers.map((num) => num * num );
	console.log(squares); // [1, 4, 9, 16]

// 객체 배열에서 특정 속성 추출
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' },
	    ];
	const names = users.map((user) => user.name);
	console.log(names); // ['Alice', 'Bob', 'Charlie']
]

# filter 메서드
: 배열의 각 요소를 검사하여 조건 만족하는 요소만 추출, 새로운 배열로 반환
array.filter( (currentValue, index, array) => { } );
// 조건이 true인 경우 요소를 반환
	currentValue: 배열의 현재 요소
		index (선택): 배열의 현재 요소의 인덱스
			array (선택): filter를 호출한 원본 배열

-예시 [

//짝수 필터링
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers =
	 numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6]

//객체 배열에서 조건에 맞는 요소 필터링
const users = [
  { id: 1, name: 'Alice', active: true }, //액티브 
  { id: 2, name: 'Bob', active: false },
  { id: 3, name: 'Charlie', active: true },
		];
	const activeUsers =
		 users.filter((user) => user.active); //액티브 활성화
console.log(activeUsers); 
// [{ id: 1, name: 'Alice', active: true }, 
//  { id: 3, name: 'Charlie', active: true }]


]

### 비교 ###
map: 배열의 요소를 변환하여 새로운 배열 생성
모든 요소 포함 (원본 배열과 동일한 크기)
-------
filter: 조건을 만족하는 요소만 새로운 배열에 포함
조건 만족 요소

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

자바스크립트 표현식 사용하기

function App() {
  const name = '리액트';
  return (		          true일때 출력.	false일때 출력.
       {name === '리액트' ? ( 리액트입니다. ) : ( 리액트가 아닙니다. )}     
   ); } 
=> 조건 확인		조건 평가			결과 렌더링
name === '리액트'		? 연산자로 조건 평가		조건에 따라 다른 요소 렌더링


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# props 이해하기

: properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 요소


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

# state 이해하기
: 컴포넌트 내부에서 바뀔 수 있는 값을 의미
[props] 는 부모 컴포넌트가 설정하는 읽기 전용 값이며, 
	[state] 는 컴포넌트 자체적으로 관리하는 값

- 클래스형 컴포넌트
class Counter extends Component {
  	constructor(props) {
    	super(props);
    		// state의 초깃값 설정하기
    		this.state = {
      		number: 0,
    		};
  	}...

여러 값 관리하기		함수형 업데이트		
this.state = {		this.setState(prevState => ({
  number: 0,		number: prevState.number + 1
  fixedNumber: 0,		}));
};

콜백 함수 등록
this.setState(
  { number: number + 1 },
  () => {
    console.log('setState가 완료되었습니다.');
    console.log(this.state);
  }
);

# 4 리액트 이벤트핸들러
- 임의 메서드 만들기
ㅡ기본 방식ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
constructor에서 메서드를 바인딩합니다.

constructor(props) {
  super(props);
  this.handleChange = this.handleChange.bind(this);
  this.handleClick = this.handleClick.bind(this);
}

handleChange(e) {
  this.setState({ message: e.target.value });
}

handleClick() {
  alert(this.state.message);
  this.setState({ message: '' });
}

ㅡ화살표 함수 방식ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Property Initializer Syntax를 사용한 메서드 작성

handleChange = (e) => {
  this.setState({ message: e.target.value });
};

handleClick = () => {
  alert(this.state.message);
  this.setState({ message: '' });
};

=> 결론 : 화살표 함수를 사용하면 바인딩 작업 없이
    메서드를 정의할 수 있어 더 간결한 코드를 작성할 수 있음.

# 6 key ( 언제나 유일, 데이터가 가진 고유값 설정)
: 컴포넌트 배열 렌더링 시 어떤 원소에 변동이 있었는지 알아내기 위해 사용
    어떤 변화가 일어났는지 더욱 빠르게 알아낼 수 있음.

# 데이터 추가 기능 구현
- push: 기존 배열 자체를 변경

- concat: 새로운 배열을 생성

- 주의!
리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서
새로운 값을 상태로 설정해야 합니다. ( = 불변성 유지 )

# 7 라이프사이클 메서드
- 마운트
: DOM이 생성되고 웹 브라우저상에 나타나는 과정

- 언마운트
: 컴포넌트가 페이지에서 사라지는 과정
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
- 업데이트 (P S 부 강)
1 'P'rops변경 / 2 'S'tate 변경 / 3 '부'모 컴포넌트 리렌더링
/ 4 FORCE update호출
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# 8 Hooks
- useState - 상태 관리
: const [state, setState] = useState(초깃값);
\\\\\

- useEffect - 사이드 이펙트 처리
: useEffect(() => { // 실행할 작업
    return () => { // cleanup 함수
    };
  }, [의존성 배열]);
     여기서 [의존성 배열]?
    생략 ->        매 렌더링마다
    []  ->        마운트 시 1회만
    [값1, 값2] ->  해당 값 변경 시
\\\\\

- useReducer - 복잡한 상태 관리
: const [state, dispatch] = useReducer(reducer, initialState);
                dispatch: 액션을 발생시키는 함수
                            reducer: 상태 업데이트 로직을 담은 함수
        action: 업데이트 정보를 담은 객체
\\\\\

- useMemo - 연산 최적화
: const memoizedValue = useMemo(
    () => computeExpensiveValue(a, b),
    [a, b]
  );
  특정 값이 바뀔 때만 연산 실행.
  이전 연산 결과를 재사용
\\\\\

- useCallback - 함수 최적화
: const memoizedCallback = useCallback(
    () => {/* 함수 내용 */
    }, [의존성 배열]
  );
  -> 함수 재사용. 불필요한 리렌더링 방지.
\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
useMemo vs useCallback

// useMemo: 값을 메모이제이션
const value = useMemo(() => fn(), [deps]);

// useCallback: 함수 자체를 메모이제이션
const fn = useCallback(() => {}, [deps]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

        *결론*
단순 상태 관리    ->  useState

복잡한 상태 로직   ->  useReducer

컴포넌트 생명주기   ->  useEffect

비용이 큰 연산 최적화    ->  useMemo

함수 재사용  ->  useCallback

DOM 접근 필요   ->  useRef

로직 재사용커스텀   ->  Hook
